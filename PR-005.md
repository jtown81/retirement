# PR-005: Named Scenario Management & Comparison — Plan

## Context

We've completed PR-001 through PR-004:
- **PR-001:** Tax module foundation (federal brackets, SS provisional income, IRMAA)
- **PR-002:** Tax storage, schema v2 migration, TaxProfileForm
- **PR-003:** Tax integration into useSimulation pipeline + TaxImpactChart
- **PR-004:** TSP monitoring (balance history, fund allocation, CSV import)

Now we build the **Scenario Management** system: users can save their current plan as a named scenario, compare two scenarios side-by-side, and manage multiple "what-if" versions of their retirement plan.

**Key capabilities:**
1. Save current inputs as a named scenario (snapshot of all form data + simulation result)
2. Load a saved scenario as the baseline for editing
3. Compare two scenarios in a 2-column metric table with delta column
4. Delete, rename, and pin scenarios
5. Navigate between My Plan and Scenarios views

This foundation enables future features like Monte Carlo risk analysis per scenario, Roth conversion ladder optimization, and multi-profile family planning.

## Implementation Plan

### Files to Create/Modify

#### 1. `app/src/models/scenario.ts` (Create)
**Purpose:** Define scenario data model and storage structure.

**Key types:**

```typescript
import type { ISODate, USD } from './common';
import type { SimulationInput } from './simulation';

/** A full simulation result snapshot for comparison purposes */
export interface FullSimulationResult {
  /** Age at which TSP balance hits zero (null if never depletes) */
  depletionAge: number | null;
  /** TSP balance at age 85 */
  balanceAt85: USD;
  /** Sum of all gross income across projection years */
  totalLifetimeIncome: USD;
  /** Sum of all federal + state + IRMAA taxes */
  totalLifetimeTax: USD;
  /** totalLifetimeIncome - totalLifetimeTax */
  totalLifetimeAfterTaxIncome: USD;
  /** All years of the projection */
  years: SimulationYearResult[];
}

/** A user-saved retirement plan scenario */
export interface NamedScenario {
  /** Unique identifier (UUID) */
  id: string;
  /** User-defined label (e.g., "Retire at 57 — MRA+30") */
  label: string;
  /** ISO date when scenario was created */
  createdAt: ISODate;
  /** Optional user description */
  description?: string;
  /** Snapshot of all form inputs at time of save */
  inputs: SimulationInput;
  /** Snapshot of full simulation result at time of save */
  result: FullSimulationResult;
  /** Whether this is the "baseline" scenario for comparison */
  isBaseline: boolean;
  /** ISO date when scenario was last modified */
  updatedAt?: ISODate;
}

/** Comparison metrics extracted from a scenario for the comparison table */
export interface ScenarioComparisonMetrics {
  scenarioId: string;
  label: string;
  // Year 1 metrics
  year1Annuity: USD;
  year1SupplementaryAnnuity: USD;
  year1SocialSecurity: USD;
  year1TSPWithdrawal: USD;
  year1GrossIncome: USD;
  year1FederalTax: USD;
  year1StateTax: USD;
  year1IrmaaSurcharge: USD;
  year1AfterTaxIncome: USD;
  year1MonthlyAfterTax: USD;
  // Lifecycle metrics
  depletionAge: number | null;
  balanceAt85: USD;
  // Tax metrics
  totalLifetimeTax: USD;
  effectiveFederalRate: number; // as percentage (e.g., 11.5 → "11.5%")
  effectiveTotalRate: number;
  // Longevity metrics
  totalLifetimeIncome: USD;
  totalLifetimeAfterTaxIncome: USD;
  // User inputs (for reference)
  retirementAge: number;
  years: number; // length of projection
}

/** Delta between two scenarios for display */
export interface ScenarioDelta {
  label: string;
  baselineValue: number | USD | null;
  comparisonValue: number | USD | null;
  deltaValue: number | USD;
  deltaPercentage: number; // e.g., 5.2 for +5.2%
  isImprovement: boolean; // true if delta is positive for this metric
}
```

---

#### 2. `app/src/storage/schema.ts` (Edit)
**Purpose:** Add NAMED_SCENARIOS storage key.

**Changes:**
```typescript
export const STORAGE_KEYS = {
  // ... existing keys ...
  NAMED_SCENARIOS: 'retire:named-scenarios',  // NEW: NamedScenario[]
} as const;
```

---

#### 3. `app/src/storage/zod-schemas.ts` (Edit)
**Purpose:** Add Zod schemas for scenario validation.

**Add:**
```typescript
import { z } from 'zod';
import type { NamedScenario, FullSimulationResult, ScenarioComparisonMetrics } from '@models/scenario';

export const FullSimulationResultSchema = z.object({
  depletionAge: z.number().int().positive().nullable(),
  balanceAt85: z.number().nonnegative(),
  totalLifetimeIncome: z.number().nonnegative(),
  totalLifetimeTax: z.number().nonnegative(),
  totalLifetimeAfterTaxIncome: z.number().nonnegative(),
  years: z.array(SimulationYearResultSchema), // reference existing schema
}) satisfies z.ZodType<FullSimulationResult>;

export const NamedScenarioSchema = z.object({
  id: z.string().uuid(),
  label: z.string().min(1).max(200),
  createdAt: z.string().date(),
  description: z.string().optional(),
  inputs: SimulationInputSchema, // reference existing schema
  result: FullSimulationResultSchema,
  isBaseline: z.boolean(),
  updatedAt: z.string().date().optional(),
}) satisfies z.ZodType<NamedScenario>;

export const NamedScenariosArraySchema = z.array(NamedScenarioSchema);
```

---

#### 4. `app/src/hooks/useScenarioManager.ts` (Create)
**Purpose:** Custom hook for scenario CRUD operations and comparison logic.

**Key functions:**

```typescript
import { useLocalStorage } from './useLocalStorage';
import { STORAGE_KEYS } from '@storage/schema';
import { NamedScenariosArraySchema } from '@storage/zod-schemas';
import type { NamedScenario, FullSimulationResult, ScenarioComparisonMetrics } from '@models/scenario';
import type { SimulationInput } from '@models/simulation';

export function useScenarioManager() {
  const [scenarios, setScenarios] = useLocalStorage<NamedScenario[]>(
    STORAGE_KEYS.NAMED_SCENARIOS,
    NamedScenariosArraySchema,
  );

  /**
   * Save current inputs + simulation result as a new scenario
   */
  const saveScenario = useCallback(
    (label: string, inputs: SimulationInput, result: FullSimulationResult, description?: string) => {
      if (!scenarios) return null;
      const newScenario: NamedScenario = {
        id: crypto.randomUUID?.() ?? generateId(),
        label,
        createdAt: new Date().toISOString().split('T')[0],
        description,
        inputs,
        result,
        isBaseline: scenarios.length === 0, // first scenario is baseline
      };
      setScenarios([...scenarios, newScenario]);
      return newScenario.id;
    },
    [scenarios, setScenarios],
  );

  /**
   * Load a saved scenario's inputs back into the form
   */
  const loadScenario = useCallback(
    (id: string) => {
      const scenario = scenarios?.find((s) => s.id === id);
      if (!scenario) return null;
      // Note: caller will use scenario.inputs to populate forms via useLocalStorage
      return scenario;
    },
    [scenarios],
  );

  /**
   * Update scenario label and description
   */
  const updateScenario = useCallback(
    (id: string, updates: { label?: string; description?: string }) => {
      if (!scenarios) return;
      setScenarios(
        scenarios.map((s) =>
          s.id === id
            ? { ...s, ...updates, updatedAt: new Date().toISOString().split('T')[0] }
            : s,
        ),
      );
    },
    [scenarios, setScenarios],
  );

  /**
   * Delete a scenario
   */
  const deleteScenario = useCallback(
    (id: string) => {
      if (!scenarios) return;
      // Don't allow deletion if it's the only baseline
      const baselines = scenarios.filter((s) => s.isBaseline);
      if (baselines.length === 1 && baselines[0].id === id) {
        throw new Error('Cannot delete the last baseline scenario');
      }
      setScenarios(scenarios.filter((s) => s.id !== id));
    },
    [scenarios, setScenarios],
  );

  /**
   * Set which scenario is the baseline for comparison
   */
  const setBaseline = useCallback(
    (id: string) => {
      if (!scenarios) return;
      setScenarios(
        scenarios.map((s) => ({
          ...s,
          isBaseline: s.id === id,
        })),
      );
    },
    [scenarios, setScenarios],
  );

  /**
   * Get the baseline scenario
   */
  const getBaseline = useCallback(() => {
    return scenarios?.find((s) => s.isBaseline) ?? null;
  }, [scenarios]);

  /**
   * Extract comparison metrics from a scenario
   */
  const getComparisonMetrics = useCallback(
    (scenario: NamedScenario): ScenarioComparisonMetrics => {
      const year1 = scenario.result.years[0];
      return {
        scenarioId: scenario.id,
        label: scenario.label,
        year1Annuity: year1?.annuity ?? 0,
        year1SupplementaryAnnuity: year1?.fersSupplement ?? 0,
        year1SocialSecurity: year1?.socialSecurity ?? 0,
        year1TSPWithdrawal: year1?.tspWithdrawal ?? 0,
        year1GrossIncome: year1?.totalIncome ?? 0,
        year1FederalTax: year1?.federalTax ?? 0,
        year1StateTax: year1?.stateTax ?? 0,
        year1IrmaaSurcharge: year1?.irmaaSurcharge ?? 0,
        year1AfterTaxIncome: year1?.afterTaxIncome ?? 0,
        year1MonthlyAfterTax: (year1?.afterTaxIncome ?? 0) / 12,
        depletionAge: scenario.result.depletionAge,
        balanceAt85: scenario.result.balanceAt85,
        totalLifetimeTax: scenario.result.totalLifetimeTax,
        effectiveFederalRate: scenario.result.years.length > 0
          ? ((scenario.result.totalLifetimeTax / scenario.result.totalLifetimeIncome) * 100)
          : 0,
        effectiveTotalRate: scenario.result.years.length > 0
          ? ((scenario.result.totalLifetimeTax / scenario.result.totalLifetimeIncome) * 100)
          : 0,
        totalLifetimeIncome: scenario.result.totalLifetimeIncome,
        totalLifetimeAfterTaxIncome: scenario.result.totalLifetimeAfterTaxIncome,
        retirementAge: scenario.inputs.retirementAge,
        years: scenario.result.years.length,
      };
    },
    [],
  );

  return {
    scenarios: scenarios ?? [],
    saveScenario,
    loadScenario,
    updateScenario,
    deleteScenario,
    setBaseline,
    getBaseline,
    getComparisonMetrics,
  };
}

function generateId(): string {
  return `${Date.now()}-${Math.random().toString(36).slice(2, 9)}`;
}
```

---

#### 5. `app/src/utils/scenario-comparison.ts` (Create)
**Purpose:** Utility functions for scenario comparison calculations.

```typescript
import type { ScenarioComparisonMetrics, ScenarioDelta } from '@models/scenario';

/**
 * Compute delta between two scenarios for a single metric
 */
export function computeMetricDelta(
  metricName: keyof ScenarioComparisonMetrics,
  baseline: ScenarioComparisonMetrics,
  comparison: ScenarioComparisonMetrics,
): ScenarioDelta {
  const baselineValue = baseline[metricName];
  const comparisonValue = comparison[metricName];

  if (typeof baselineValue !== 'number' || typeof comparisonValue !== 'number') {
    return {
      label: metricName,
      baselineValue,
      comparisonValue,
      deltaValue: 0,
      deltaPercentage: 0,
      isImprovement: false,
    };
  }

  const deltaValue = comparisonValue - baselineValue;
  const deltaPercentage = baselineValue !== 0
    ? ((deltaValue / Math.abs(baselineValue)) * 100)
    : 0;

  // Determine if improvement based on metric (some metrics are better if lower)
  const lowerIsBetter = [
    'year1FederalTax',
    'year1StateTax',
    'year1IrmaaSurcharge',
    'totalLifetimeTax',
    'effectiveFederalRate',
    'effectiveTotalRate',
  ];
  const isImprovement = lowerIsBetter.includes(metricName)
    ? deltaValue < 0
    : deltaValue > 0;

  return {
    label: metricName,
    baselineValue,
    comparisonValue,
    deltaValue,
    deltaPercentage,
    isImprovement,
  };
}

/**
 * Format a scenario metric for display
 */
export function formatMetric(name: keyof ScenarioComparisonMetrics, value: any): string {
  if (typeof value !== 'number') return String(value);

  // Currency fields
  if (name.includes('Year1') || name.includes('Total') || name.includes('Balance') || name.includes('Annuity')) {
    return `$${value.toLocaleString('en-US', { maximumFractionDigits: 0 })}`;
  }

  // Percentage fields
  if (name.includes('Rate')) {
    return `${value.toFixed(1)}%`;
  }

  // Monthly income
  if (name === 'year1MonthlyAfterTax') {
    return `$${value.toLocaleString('en-US', { maximumFractionDigits: 0 })}/mo`;
  }

  // Age fields
  if (name === 'depletionAge' || name === 'retirementAge') {
    return value === null ? 'Never' : `Age ${Math.round(value)}`;
  }

  // Integer fields
  if (name === 'years') {
    return `${value} years`;
  }

  return String(value);
}

/**
 * Format delta for display
 */
export function formatDelta(delta: ScenarioDelta): string {
  if (typeof delta.deltaValue !== 'number') return '—';

  const sign = delta.deltaValue > 0 ? '+' : delta.deltaValue < 0 ? '−' : '';
  const metric = delta.label.includes('Rate')
    ? `${sign}${Math.abs(delta.deltaPercentage).toFixed(1)}pp`
    : `${sign}$${Math.abs(delta.deltaValue).toLocaleString('en-US', { maximumFractionDigits: 0 })}`;

  const arrow = delta.isImprovement ? ' ▲' : delta.deltaValue !== 0 ? ' ▼' : '';
  return `${metric}${arrow}`;
}
```

---

#### 6. `app/src/components/layout/AppShell.tsx` (Edit)
**Purpose:** Add "Scenarios" top-level navigation tab.

**Changes:**
- Add new top-level nav item: "Scenarios" with icon (e.g., `GitBranch` or `Layers` from lucide-react)
- Route to new `ScenariosPage` component
- Update `currentView` type to include `'scenarios'`

**Pseudo-code:**
```tsx
const navItems = [
  { label: 'My Plan', view: 'my-plan', icon: FileText },
  { label: 'Tax', view: 'tax', icon: DollarSign },
  { label: 'Leave', view: 'leave', icon: Calendar },
  { label: 'Scenarios', view: 'scenarios', icon: GitBranch }, // NEW
  { label: 'Dashboard', view: 'dashboard', icon: BarChart3, disabled: !isComplete },
];
```

---

#### 7. `app/src/components/scenarios/ScenarioManager.tsx` (Create)
**Purpose:** List all saved scenarios, with controls to save, load, rename, delete, and set baseline.

**Structure:**

```tsx
export function ScenarioManager() {
  const { scenarios, saveScenario, deleteScenario, updateScenario, setBaseline, getBaseline } = useScenarioManager();
  const { getComparisonMetrics } = useScenarioManager();
  const input = useAssembleInput();
  const simResult = useSimulation(input);
  const [showSaveDialog, setShowSaveDialog] = useState(false);
  const [editingId, setEditingId] = useState<string | null>(null);
  const [editLabel, setEditLabel] = useState('');
  const [editDescription, setEditDescription] = useState('');

  const handleSave = (label: string, description?: string) => {
    if (!input || !simResult) return;
    saveScenario(label, input, simResult, description);
    setShowSaveDialog(false);
  };

  const baseline = getBaseline();

  return (
    <div className="space-y-6 max-w-4xl mx-auto">
      <h1 className="text-2xl font-bold">Scenarios</h1>

      {/* Save Current State Button */}
      <button
        onClick={() => setShowSaveDialog(true)}
        className="px-4 py-2 bg-blue-600 text-white rounded-lg"
      >
        Save Current Plan as Scenario
      </button>

      {/* Save Dialog */}
      {showSaveDialog && (
        <SaveScenarioDialog
          onSave={handleSave}
          onCancel={() => setShowSaveDialog(false)}
        />
      )}

      {/* Scenarios List */}
      {scenarios.length === 0 ? (
        <p className="text-gray-500">No scenarios saved yet. Create one to start comparing.</p>
      ) : (
        <div className="space-y-3">
          {scenarios.map((scenario) => (
            <ScenarioListItem
              key={scenario.id}
              scenario={scenario}
              isBaseline={baseline?.id === scenario.id}
              onSetBaseline={() => setBaseline(scenario.id)}
              onDelete={() => deleteScenario(scenario.id)}
              onEdit={(id, label, desc) => {
                setEditingId(id);
                setEditLabel(label);
                setEditDescription(desc);
              }}
              onLoadScenario={() => {
                // Populate forms with scenario inputs (see integration section)
              }}
            />
          ))}
        </div>
      )}

      {/* Edit Dialog */}
      {editingId && (
        <EditScenarioDialog
          label={editLabel}
          description={editDescription}
          onSave={(label, desc) => {
            updateScenario(editingId, { label, description: desc });
            setEditingId(null);
          }}
          onCancel={() => setEditingId(null)}
        />
      )}

      {/* Quick Stats */}
      {scenarios.length > 0 && (
        <div className="bg-gray-50 p-4 rounded-lg">
          <h3 className="font-semibold mb-2">Saved Scenarios</h3>
          <p className="text-sm text-gray-600">
            Total: {scenarios.length} scenarios | Baseline: <strong>{baseline?.label}</strong>
          </p>
        </div>
      )}
    </div>
  );
}
```

---

#### 8. `app/src/components/scenarios/ScenarioListItem.tsx` (Create)
**Purpose:** Individual scenario row in the list with actions.

**Display:**
- Scenario label (bold)
- Description (gray, smaller)
- Created date (right-aligned, gray)
- Baseline badge (if applicable)
- Action buttons:
  - "Compare" → route to comparison view with this as selected
  - "Set Baseline" (if not already baseline)
  - "Rename" → edit dialog
  - "Delete" → confirm dialog
  - "Load" → populate forms with this scenario's inputs

---

#### 9. `app/src/components/scenarios/ScenarioComparison.tsx` (Create)
**Purpose:** 2-column comparison table showing metrics side-by-side with deltas.

**Structure:**

```tsx
export function ScenarioComparison() {
  const { getBaseline, scenarios, getComparisonMetrics } = useScenarioManager();
  const [selectedScenarioId, setSelectedScenarioId] = useState<string | null>(null);

  const baseline = getBaseline();
  const selected = scenarios.find((s) => s.id === selectedScenarioId);

  if (!baseline || !selected) {
    return (
      <div className="p-6 bg-blue-50 rounded-lg">
        <p>Select a baseline and comparison scenario above to see metrics side-by-side.</p>
      </div>
    );
  }

  const baselineMetrics = getComparisonMetrics(baseline);
  const selectedMetrics = getComparisonMetrics(selected);

  const metricRows: MetricRow[] = [
    // Income section
    { group: 'Year 1 Income', metrics: ['year1Annuity', 'year1SupplementaryAnnuity', 'year1SocialSecurity', 'year1TSPWithdrawal', 'year1GrossIncome'] },
    { group: 'Year 1 Taxes & Deductions', metrics: ['year1FederalTax', 'year1StateTax', 'year1IrmaaSurcharge'] },
    { group: 'Year 1 After-Tax', metrics: ['year1AfterTaxIncome', 'year1MonthlyAfterTax'] },
    { group: 'Lifetime Summary', metrics: ['totalLifetimeIncome', 'totalLifetimeTax', 'totalLifetimeAfterTaxIncome', 'effectiveFederalRate'] },
    { group: 'TSP & Longevity', metrics: ['depletionAge', 'balanceAt85'] },
  ];

  return (
    <div className="space-y-6">
      <h2 className="text-xl font-bold">Scenario Comparison</h2>

      {/* Scenario selector */}
      <div className="flex gap-4">
        <div>
          <label className="block text-sm font-semibold mb-2">Baseline Scenario</label>
          <div className="p-3 bg-gray-50 rounded border">{baseline.label}</div>
        </div>
        <div>
          <label className="block text-sm font-semibold mb-2">Compare To</label>
          <select
            value={selectedScenarioId ?? ''}
            onChange={(e) => setSelectedScenarioId(e.target.value)}
            className="border rounded px-3 py-2"
          >
            <option value="">Select a scenario...</option>
            {scenarios
              .filter((s) => s.id !== baseline.id)
              .map((s) => (
                <option key={s.id} value={s.id}>{s.label}</option>
              ))}
          </select>
        </div>
      </div>

      {/* Comparison table */}
      <div className="overflow-x-auto">
        <table className="w-full border-collapse text-sm">
          <thead>
            <tr className="bg-gray-100 border-b">
              <th className="text-left px-4 py-2 font-semibold">Metric</th>
              <th className="text-right px-4 py-2 font-semibold">{baseline.label}</th>
              <th className="text-right px-4 py-2 font-semibold">{selected.label}</th>
              <th className="text-right px-4 py-2 font-semibold">Delta</th>
            </tr>
          </thead>
          <tbody>
            {metricRows.map((row) => (
              <React.Fragment key={row.group}>
                {/* Group header */}
                <tr className="bg-blue-50 border-t">
                  <td colSpan={4} className="px-4 py-2 font-semibold text-gray-700">
                    {row.group}
                  </td>
                </tr>
                {/* Metric rows */}
                {row.metrics.map((metricName) => {
                  const delta = computeMetricDelta(
                    metricName as any,
                    baselineMetrics,
                    selectedMetrics,
                  );
                  const deltaClass = delta.isImprovement
                    ? 'text-green-600'
                    : delta.deltaValue !== 0
                    ? 'text-red-600'
                    : '';

                  return (
                    <tr key={metricName} className="border-b hover:bg-gray-50">
                      <td className="px-4 py-2 text-gray-700">{prettifyMetricName(metricName)}</td>
                      <td className="text-right px-4 py-2">{formatMetric(metricName, baselineMetrics[metricName as any])}</td>
                      <td className="text-right px-4 py-2">{formatMetric(metricName, selectedMetrics[metricName as any])}</td>
                      <td className={`text-right px-4 py-2 font-semibold ${deltaClass}`}>
                        {formatDelta(delta)}
                      </td>
                    </tr>
                  );
                })}
              </React.Fragment>
            ))}
          </tbody>
        </table>
      </div>

      {/* Interpretation tip */}
      <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-4">
        <p className="text-sm text-gray-700">
          <strong>△ Green up arrow</strong> = improvement (higher income, lower taxes, longer TSP balance)
          {' '}
          <strong>▼ Red down arrow</strong> = disadvantage
        </p>
      </div>
    </div>
  );
}

function prettifyMetricName(name: string): string {
  return name
    .replace(/([A-Z])/g, ' $1')
    .replace(/^./, (c) => c.toUpperCase())
    .trim();
}
```

---

#### 10. `app/src/components/scenarios/SaveScenarioDialog.tsx` (Create)
**Purpose:** Modal dialog to save current plan as a named scenario.

**Fields:**
- **Label** (required, 1–200 chars) — scenario name
- **Description** (optional, up to 500 chars) — notes
- **Buttons:** Save | Cancel

**Validation:**
- Label cannot be empty
- Label must be unique across saved scenarios (warn if duplicate, allow override)

---

#### 11. `app/src/components/scenarios/EditScenarioDialog.tsx` (Create)
**Purpose:** Modal to edit scenario label and description.

**Fields:** same as SaveScenarioDialog

---

#### 12. `app/src/hooks/usePersistentScenarioState.ts` (Create)
**Purpose:** Helper hook to load a scenario's inputs into all the form fields.

**Logic:**
```typescript
export function usePersistentScenarioState() {
  const {
    setPersonalInfo,
    setCareerProfile,
    setExpenseProfile,
    setTaxProfile,
    setTspSnapshots,
    setSimulationConfig,
  } = useMultipleLocalStorage(); // or individual hooks

  const loadScenario = useCallback((scenario: NamedScenario) => {
    // Populate each form section from scenario.inputs
    setPersonalInfo(scenario.inputs.personalInfo);
    setCareerProfile(scenario.inputs.careerProfile);
    // ... etc

    // Show confirmation toast
    toast.success(`Loaded scenario: ${scenario.label}`);
  }, [setPersonalInfo, setCareerProfile, /* ... */]);

  return { loadScenario };
}
```

---

#### 13. `app/src/pages/scenarios.astro` (Create or route in existing)
**Purpose:** Page/route for the Scenarios view.

If using SPA routing in React:
- Add route handler in `PlannerApp.tsx` for `currentView === 'scenarios'`
- Render `ScenarioManager` + `ScenarioComparison` side-by-side (or tabbed)

If using Astro page:
- Create `pages/scenarios.astro` with `<ScenarioManager client:load />`

---

#### 14. `app/tests/unit/scenario/comparison.test.ts` (Create)
**Purpose:** Unit tests for scenario comparison logic.

**Test cases:**

```typescript
describe('computeMetricDelta', () => {
  const baseline: ScenarioComparisonMetrics = {
    scenarioId: 'base',
    label: 'Baseline',
    year1Annuity: 27900,
    year1GrossIncome: 58200,
    year1FederalTax: 6420,
    totalLifetimeIncome: 1847569,
    totalLifetimeTax: 187450,
    totalLifetimeAfterTaxIncome: 1660119,
    effectiveFederalRate: 11.0,
    depletionAge: null,
    balanceAt85: 723456,
    year1SupplementaryAnnuity: 12300,
    year1SocialSecurity: 0,
    year1TSPWithdrawal: 18000,
    year1StateTax: 0,
    year1IrmaaSurcharge: 0,
    year1AfterTaxIncome: 51780,
    year1MonthlyAfterTax: 4315,
    retirementAge: 57,
    years: 40,
  };

  const scenario: ScenarioComparisonMetrics = {
    ...baseline,
    year1Annuity: 31200,
    year1GrossIncome: 62400,
    year1FederalTax: 7100,
    totalLifetimeTax: 195620,
    totalLifetimeIncome: 1987234,
  };

  test('Positive delta for year1Annuity shows improvement', () => {
    const delta = computeMetricDelta('year1Annuity', baseline, scenario);
    expect(delta.deltaValue).toBe(3300);
    expect(delta.isImprovement).toBe(true);
  });

  test('Negative delta for federalTax shows improvement', () => {
    const delta = computeMetricDelta('year1FederalTax', baseline, scenario);
    expect(delta.deltaValue).toBe(680);
    expect(delta.isImprovement).toBe(false); // higher tax is worse
  });

  test('Delta percentage calculated correctly', () => {
    const delta = computeMetricDelta('year1Annuity', baseline, scenario);
    expect(delta.deltaPercentage).toBeCloseTo(11.83, 1); // +11.83%
  });
});

describe('formatMetric', () => {
  test('Currency values formatted with commas', () => {
    expect(formatMetric('year1Annuity', 27900)).toBe('$27,900');
  });

  test('Age formatted as "Age X"', () => {
    expect(formatMetric('depletionAge', 81)).toBe('Age 81');
  });

  test('Null depletionAge formatted as "Never"', () => {
    expect(formatMetric('depletionAge', null)).toBe('Never');
  });

  test('Rate formatted with %', () => {
    expect(formatMetric('effectiveFederalRate', 11.0)).toBe('11.0%');
  });
});

describe('formatDelta', () => {
  test('Positive delta formatted with + and green arrow', () => {
    const delta = { label: 'year1Annuity', deltaValue: 3300, isImprovement: true, deltaPercentage: 11.83 };
    expect(formatDelta(delta)).toMatch(/\+.*▲/);
  });

  test('Negative tax delta shows as improvement with ▲', () => {
    const delta = { label: 'year1FederalTax', deltaValue: -680, isImprovement: true, deltaPercentage: -10.5 };
    expect(formatDelta(delta)).toMatch(/▲/);
  });
});
```

---

#### 15. `app/tests/unit/scenario/manager.test.ts` (Create)
**Purpose:** Unit tests for scenario manager hook.

**Test cases:**

```typescript
describe('useScenarioManager', () => {
  test('saveScenario creates new scenario with UUID', () => {
    const { saveScenario, scenarios } = renderHook(() => useScenarioManager()).result.current;
    const id = saveScenario('My Plan', mockInput, mockResult);
    expect(scenarios).toHaveLength(1);
    expect(scenarios[0].id).toBeDefined();
    expect(scenarios[0].label).toBe('My Plan');
  });

  test('First scenario is marked as baseline', () => {
    const { saveScenario, scenarios } = renderHook(() => useScenarioManager()).result.current;
    saveScenario('First', mockInput, mockResult);
    expect(scenarios[0].isBaseline).toBe(true);
  });

  test('Subsequent scenarios are not baseline', () => {
    // ... add two scenarios
    expect(scenarios[0].isBaseline).toBe(true);
    expect(scenarios[1].isBaseline).toBe(false);
  });

  test('deleteScenario removes scenario', () => {
    // ... add and delete
    expect(scenarios).not.toContainEqual(expect.objectContaining({ id: deletedId }));
  });

  test('Cannot delete the only baseline', () => {
    const { deleteScenario, scenarios } = renderHook(() => useScenarioManager()).result.current;
    saveScenario('Only Baseline', mockInput, mockResult);
    expect(() => deleteScenario(scenarios[0].id)).toThrow('Cannot delete the last baseline scenario');
  });

  test('updateScenario modifies label and description', () => {
    // ... add scenario
    updateScenario(id, { label: 'Updated', description: 'New desc' });
    const updated = scenarios.find((s) => s.id === id);
    expect(updated?.label).toBe('Updated');
    expect(updated?.description).toBe('New desc');
  });

  test('setBaseline switches baseline', () => {
    // ... add two scenarios
    setBaseline(scenarios[1].id);
    expect(getBaseline().id).toBe(scenarios[1].id);
  });

  test('getComparisonMetrics extracts year 1 and lifetime data', () => {
    const metrics = getComparisonMetrics(scenario);
    expect(metrics.year1Annuity).toBe(scenario.result.years[0].annuity);
    expect(metrics.totalLifetimeIncome).toBe(scenario.result.totalLifetimeIncome);
  });
});
```

---

#### 16. `app/tests/scenarios/scenario-comparison.test.ts` (Create)
**Purpose:** End-to-end scenario comparison test.

**Test case:**
```typescript
test('GS straight-through vs Retire at 57 scenario comparison', () => {
  // Load baseline scenario from fixture
  const baseline = loadScenarioFixture('gs-straight-57');
  const comparison = loadScenarioFixture('gs-straight-60');

  const baselineMetrics = getComparisonMetrics(baseline);
  const comparisonMetrics = getComparisonMetrics(comparison);

  // Verify baseline year 1 income
  expect(baselineMetrics.year1GrossIncome).toBeCloseTo(58200, -2); // ±$100
  expect(baselineMetrics.year1AfterTaxIncome).toBeCloseTo(51780, -2);

  // Verify working 3 more years increases annuity
  expect(comparisonMetrics.year1Annuity).toBeGreaterThan(baselineMetrics.year1Annuity);

  // Verify deltas computed correctly
  const delta = computeMetricDelta('year1Annuity', baselineMetrics, comparisonMetrics);
  expect(delta.isImprovement).toBe(true);
  expect(delta.deltaPercentage).toBeGreaterThan(0);
});
```

---

#### 17. `app/src/models/simulation.ts` (Edit - if needed)
**Purpose:** Ensure `SimulationInput` is exported and complete for scenario storage.

**Verify:**
- `SimulationInput` captures all form data (personal, career, expenses, tax, simulation config, TSP snapshots)
- All fields are serializable (no functions, Date objects use ISO strings)

---

#### 18. `app/src/utils/index.ts` (Edit - if barrel export)
**Purpose:** Export scenario utilities.

```typescript
export * from './scenario-comparison';
```

---

### Data Models Summary

**New types added to `models/scenario.ts`:**
- `FullSimulationResult`
- `NamedScenario`
- `ScenarioComparisonMetrics`
- `ScenarioDelta`

**Storage key added:**
```typescript
STORAGE_KEYS.NAMED_SCENARIOS: 'retire:named-scenarios'
```

**Storage structure:**
```json
{
  "schemaVersion": 2,
  "updatedAt": "2026-02-18T12:00:00Z",
  "data": [
    {
      "id": "uuid-001",
      "label": "Retire at 57 — MRA+30",
      "createdAt": "2026-02-17",
      "description": "Conservative plan: retire at MRA with 31 years service",
      "isBaseline": true,
      "updatedAt": "2026-02-18",
      "inputs": { "...": "SimulationInput snapshot" },
      "result": {
        "depletionAge": null,
        "balanceAt85": 723456,
        "totalLifetimeIncome": 1847569,
        "totalLifetimeTax": 187450,
        "totalLifetimeAfterTaxIncome": 1660119,
        "years": [ "...40 SimulationYearResult objects..." ]
      }
    },
    {
      "id": "uuid-002",
      "label": "Retire at 60 — +3 years",
      "createdAt": "2026-02-17",
      "description": "Aggressive plan: work 3 more years, higher annuity",
      "isBaseline": false,
      "inputs": { "...": "SimulationInput snapshot" },
      "result": { "...": "..." }
    }
  ]
}
```

---

### Integration Points

#### 1. **Loading a Scenario into Forms**
When user clicks "Load" on a scenario:
1. Fetch scenario from `useScenarioManager`
2. Call `usePersistentScenarioState().loadScenario(scenario)`
3. This updates all form localStorage keys with scenario.inputs
4. User sees all forms populated with the scenario's saved values
5. Show toast notification: "Loaded scenario: X"

#### 2. **Saving Current State**
When user clicks "Save Current Plan as Scenario":
1. Get `input = useAssembleInput()` (returns current form data or null)
2. Get `result = useSimulation(input)` (returns full simulation result)
3. Show SaveScenarioDialog
4. On confirm, call `saveScenario(label, input, result, description)`
5. Scenario is persisted to localStorage under NAMED_SCENARIOS key
6. Show toast: "Scenario saved: X"

#### 3. **Comparison View**
- Select baseline (usually the first saved scenario)
- Select comparison scenario from dropdown
- `useScenarioManager` computes `ScenarioComparisonMetrics` for both
- `computeMetricDelta()` calculates deltas
- ScenarioComparison table renders with delta column

---

### Critical Details

1. **Baseline persistence:** First saved scenario is automatically baseline. User can change baseline via "Set Baseline" action. Only one baseline at a time.

2. **Scenario snapshots:** Each scenario stores a complete snapshot of:
   - All form inputs (`SimulationInput`)
   - Full simulation result (all 40 years + summary metrics)
   - This allows comparison even if user changes their current plan

3. **UUID generation:** Use `crypto.randomUUID()` if available (all modern browsers), with fallback to timestamp-based ID.

4. **Scenario immutability:** Once saved, scenario is immutable except for label/description updates. User cannot edit a scenario's inputs/result — they must "Load" it, modify the plan, and "Save as New Scenario".

5. **Delta interpretation:** For some metrics, lower is better (taxes, rates); for others, higher is better (income, balances). The `isImprovement` flag in `ScenarioDelta` handles this automatically.

---

### Testing Plan

1. **Manual tests:**
   - Save current plan as scenario 1 → verify in localStorage
   - Save different plan as scenario 2 → verify second scenario created
   - Load scenario 1 → verify forms populated
   - Click "Compare" → verify comparison table appears
   - Edit scenario label → verify update persists
   - Delete scenario → verify removed from list (with confirmation)
   - Set scenario 2 as baseline → verify baseline toggled

2. **Unit tests:**
   - `useScenarioManager` hook: CRUD operations, baseline logic
   - `computeMetricDelta` utility: delta calculation correctness
   - `formatMetric` / `formatDelta` utilities: display formatting

3. **Scenario tests:**
   - End-to-end: save → compare → verify deltas match expected values

4. **Regression:**
   - All existing 446 unit tests + 18 scenario tests still pass
   - No impact on My Plan, Tax, Leave, Dashboard views

---

### Files Affected

| File | Action | Depends On |
|---|---|---|
| `models/scenario.ts` | Create | (no deps) |
| `storage/schema.ts` | Edit — add key | (no deps) |
| `storage/zod-schemas.ts` | Edit — add schemas | (no deps) |
| `hooks/useScenarioManager.ts` | Create | models/scenario.ts, storage |
| `utils/scenario-comparison.ts` | Create | models/scenario.ts |
| `components/layout/AppShell.tsx` | Edit — add nav tab | (no deps) |
| `components/scenarios/ScenarioManager.tsx` | Create | all above |
| `components/scenarios/ScenarioListItem.tsx` | Create | models/scenario.ts |
| `components/scenarios/ScenarioComparison.tsx` | Create | utils/scenario-comparison.ts |
| `components/scenarios/SaveScenarioDialog.tsx` | Create | models/scenario.ts |
| `components/scenarios/EditScenarioDialog.tsx` | Create | models/scenario.ts |
| `hooks/usePersistentScenarioState.ts` | Create | storage |
| `pages/scenarios.astro` OR routing in PlannerApp | Create/Edit | components/scenarios/* |
| `tests/unit/scenario/comparison.test.ts` | Create | utils/scenario-comparison.ts |
| `tests/unit/scenario/manager.test.ts` | Create | hooks/useScenarioManager.ts |
| `tests/scenarios/scenario-comparison.test.ts` | Create | integration test |
| `models/simulation.ts` | Edit (verify) | (no changes needed) |

---

### Verification Checklist

- [ ] Run `pnpm typecheck` — no errors
- [ ] Run `pnpm build` — succeeds
- [ ] Run `pnpm test` — existing tests pass + new scenario tests pass
- [ ] Manual test: save current plan → verify in localStorage
- [ ] Manual test: load scenario → forms populated
- [ ] Manual test: compare two scenarios → delta column shows correct values
- [ ] Manual test: edit scenario name → persists
- [ ] Manual test: delete scenario → removed from list
- [ ] Scenarios nav tab appears in AppShell
- [ ] No TypeScript errors in components/scenarios/*

---

### Notes on Scope

**In scope for PR-005:**
- Save current inputs + result as named scenario
- List all saved scenarios with metadata
- Load scenario (populate all forms)
- Update/rename scenario
- Delete scenario
- Set baseline scenario
- 2-column comparison table with deltas
- Scenario comparison utilities (metrics extraction, delta calculation, formatting)

**Out of scope (for future PRs):**
- Monte Carlo per-scenario (PR-007)
- Roth conversion ladder optimizer (V1+)
- Multi-profile / spouse scenarios (V2)
- Scenario versioning / history (V1+)
- Scenario export/import JSON (PR-006)

---

### Dependencies & Blockers

- **PR-005 depends on:** PR-003 (tax integration; needed for complete SimulationInput)
- **PR-005 is depended on by:** PR-006 (export needs scenarios), PR-007 (Monte Carlo per scenario)
- **Can start:** Immediately after PR-003 and PR-004 land

---

### Success Criteria

- ✓ User can save current plan with name and description
- ✓ User can view all saved scenarios with metadata (label, created date, baseline badge)
- ✓ User can load a saved scenario (all forms update)
- ✓ User can rename and update scenario description
- ✓ User can delete scenario (with confirmation; cannot delete only baseline)
- ✓ User can set any scenario as baseline for comparison
- ✓ Comparison table shows 2 scenarios side-by-side with all key metrics
- ✓ Delta column shows improvement/disadvantage with arrows and percentages
- ✓ All scenarios persist to localStorage (NAMED_SCENARIOS key)
- ✓ TypeScript strict mode passes with 0 errors
- ✓ All 446 existing unit tests + 18 scenario tests still pass
- ✓ New scenario tests ≥ 90% branch coverage

